==========================================
Differences between this repo and CVS Ynot
==========================================

Postconditions are only w.r.t. final heaps, not initial and final
heaps.  (I.e., "unary postconditions" instead of "binary
postconditions")  This makes it possible to treat all implications
between specifications as implications entirely within standard
separation logic, which makes it much easier to automate the proofs.

The big consequence of this for STsep is that the rule for reading
from the heap takes an additional argument.  The declaration of this
command constructor is:

  Parameter SepRead T (p : ptr) (P : T -> hprop)
    : STsep (Exists v :@ T, p --> v * P v) (fun v => p --> v * P v).

The new parameter is [P], which is a predicate to characterize "the
part of the heap around the value you read."  For each read, you
instantiate [P] with "what you want to remember" about the value that
you're reading.  There is no argument for this being the strongest
possible rule, like you can get trivially with binary postconditions,
but it seems to work well in practice.

There is also simple support for irrelevant arguments that will be
erased during extraction.  For instance, the Stack example includes
this function to push to a stack:

  Parameter push : forall T (s : t T) (x : T) (ls : [list T]),
    STsep (ls ~~ rep s ls) (fun _ : unit => ls ~~ rep s (x :: ls)).

The type of [ls] is in brackets to indicate that that argument is
computationally irrelevant.  The [~~] operator is used to "unpack" an
irrelevant argument inside a separation logic proposition.

Finally, actual Ynot programs have much more spec annotation and much
less proof.  Every intermediate state is given an explicit
specification.  The [<@>] operator applies the frame rule, and code
like [{{c}}] applies strengthening to [c]'s precondition and weakening
to [c]'s postcondition.  (I'm told this is like "do" in classic Ynot.)
