\documentclass[preprint]{sigplanconf}
%\usepackage[square, comma, sort&compress]{natbib}

\usepackage{amsmath}
\usepackage{color}

\newcommand{\todo}[1]{\textcolor{red}{#1}}

\begin{document}

%\conferenceinfo{PLDI ’09}{ todo }

%\copyrightyear{2005}

%\copyrightdata{1-59593-056-6/05/0006}

\preprintfooter{DRAFT}

%\titlebanner{DRAFT}

\title{Title}


\authorinfo{Double blind}
{ }

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}
  Ynot is the right design from a modularity, re-use perspective.  Much of the success hinges on the use of a higher-order dependently-typed language (Coq) and the ability to smoothly integrate modeling (inductive definitions), domain-specific abstractions (e.g., STsep) and uniform abstraction (Pi). If Ynot is to succeed, need drastic improvements in automation.
  \subsection{Summary of pain from ICFP paper}
  \subsection{Contributions}
    Dramatic reduction in cost of writing/maintaining Ynot code:
    \begin{itemize}
    \item new formulation of HTT in Coq (specifically STsep)
    \item general higher-order tactic for discharging STsep VCs (sep)
    \item how how domain-specific predicates (e.g., listseg, itersep, etc.) can be integrated to keep verification burden relatively low.
    \item careful proving ``style'' avoids sensitivities that make proof
       maintenance difficult.
    \item comparison against previous work and work of others.
 \end{itemize}

\section{Overview of HTT and previous version of Ynot}
   Condensed version of ICFP paper.

\section{Ynot in practice}
  Demonstrate problems with binary post-conditions (including need for precision), size of old proofs, difficulty in maintaining them.

\section{New version of Ynot}
 Perhaps use association list as running example?
  \subsection{Re-formulate STsep to use only unary heap predicates}
     key advantage: can use traditional separation-logic reasoning.  Things to include:
     \begin{enumerate}
     \item list some of the key theorems
     \item argue that these will be strung together below with Ltac support
     \item here's where we have to fudge the issue of ``ghost'' values and the need to add an injectivity axiom.
     \item another price is that code needs more annotations (but we attempt to minimize)
     \end{enumerate}
   \subsection{new tactic library - sep}
     Explain structure of sep, sketch how it's coded, and what it can do.

\section{Imperative ADTs in Ynot 2.0}
    Focus on extensibility -- e.g., adding itersep to support arrays, adding listseg to support linked lists, etc. and showing how these get used in ADTs like the queue, hash-table, etc.

\section{Comparison}
 \subsection{comparison to old Ynot ADT implementations}

 The original formulation of Ynot lead to large, unwieldy proofs.
 Reasoning about separation logic connectives was done at the heap
 level; a larger fraction of all of our proof scripts simply massaged
 subeaps into appropriate forms.  We had some tactics that implemented
 basic operations, such as the split, join, and flattening of
 sub-heaps, but the proof writer was forced to stitch them together to
 force the heaps into the correct form.

 The focus of our re-implementation of the Ynot system has been proof
 automation.  Throught the use of the sep tactic, we have virtually
 eliminated the need to reason about heaps; reasoning is done at the
 level of seperation logic.  Much of this reasoning has in turn been
 automated by a set of tactics such as \texttt{sep auto}. These
 tactics reduce the need to reason about the connectives of separation
 logic and their properties, allowing the proof writer to focus on the
 domain specific parts of the proof.  For proofs that only have simple
 domain specific parts, \texttt{sep auto} is often able to prove them
 on its own.

 The new model uses ``ghost variables'' to simplify specifying
 properties. It does so in a way that guarantees that they are
 computationally irrelevant, and so can always be eliminated when a
 program is extracted.  This in turn allows the new model to use unary
 post-conditions, which greatly simplifies specifications and enables
 the greater automation.  The old model used binary post-conditions to
 obviate the need for ghost variables.  Binary post-conditions where
 generally harder to reason about, since the connection between pre-
 and post-conditions always needed to be re-established.  In the new
 style, the connection is built in to the specification.

 In the new Ynot, proofs are an order of magnitude shorter then they
 where in the old Ynot. (provide numbers here)

 \subsection{comparison to Jahob}

The Jahob system~\cite{jahob} allows the specification and verification of recursive, linked data structures in the Java language.  
Verified programs are correct modulo termination.

Jahob specifications are written in classical higher order logic.  The abstract state of an object is defined by the programmer using the language of set theory (including cardinality) and relations (including transitive closure).  
Methods may be annotated by hoare style pre and post conditions, with a modifies clause for framing.  
Unlike ynot, however, separation connectives are not used to describe the heap.

Jahob programs are translated into an extended guarded command language; from here, Jahob generates verification conditions which are discharged using a combination of theorem provers -- if one prover does not succeed on an obligation, another is tried.
Jahob supports a number of 1st order and SMT provers, and also the MONA prover for the monadic fragment of 2nd order logic and Isabelle and Coq. 
Like ynot, programmer annotations are used to guide the proving process.

 \subsection{comparison to Smallfoot}
We conclude our comparison with alternative approaches by comparing
our system to Smallfoot~\cite{small1,small2}. The focus of Smallfoot
is on compltely automatic reasoning, and it's almost complete nature
makes many correct programs go through with only the function level
annotations, a goal, but not yet a complete reality in Ynot. In
addition to the focus on automatic proofs, Smallfoot includes simple
concurrency primitives, $||$ and $\mathsf{with}\,r\,\mathsf{when}(B)
C$ with which they are able to implement a producer-consumer
model. Based on these points, we will draw a comparison in two parts:
the size of annotations and proof obligations and the expressivity of
the logic.

On the size of proof obligations, the Smallfoot system comes out
ahead, requiring no user-constructed proofs. The drawback to this is
that only inductive data of the following types are allowed: singly
linked lists, doubly linked lists, trees and xor lists. This
restriction is necessary to Smallfoot in order to make the proofs
decidable.

The annotations in the example programs are small mainly because they
use these. While the predicates are hard-coded in Smallfoot,
predicates can be coded directly by the user in Ynot. The style of
Ynot representations are to express data by mapping a ``ghost''
representation into a heap representation. This approach allows
stronger dependent types in the contracts for functions, requireing
the accompanying proof to be a proof of partial correctness rather
than simply of resource constraints. For example, consider the
function to test whether a list is empty in Smallfoot and in Ynot.
\begin{verbatim}
is_empty(r;l) [l |-> t * list(t)] {
  local p;
  p = l->p;
  if (p == NULL) { r = 1; } 
  else { r = 0; }
} [l|-> t * list(t)]
\end{verbatim}

The following function also has the same type:
\begin{verbatim}
is_empty(r;l) [l |-> t * list(t)] {
  r = 1;
} [l|-> t * list(t)]
\end{verbatim}
In Ynot, the \verb|is_empty| function can be defined as follows:
\begin{verbatim}
Definition is_empty A (ll : LinkedList)
  (m : [list A]) :
  STsep (m ~~ rep m ll) 
    (fun res:bool => m ~~ match res with
                            | nil => [res = true]
                            | _   => [res = false]
                          end).
  intros;
  refine (hd <- !ll;
          IfNull hd Then {{Return true}}
          Else {{Return false}}); sep simpl.
Qed.          
\end{verbatim}
The type guarantees that the function is implemented correctly with
respect to the underlying list.

\todo{This is analagous to the implementation of llseg presented in
  the smallfoot paper.}
For example, the following fixpoint expresses the recursive definition
of a linked list segement.  \todo{What is the best way to encode a
  linked list segment?}
\begin{verbatim}
Fixpoint llseg A (hd tl : option ptr) 
  (m : list A) {struct m} :=
  match m with 
    | nil => [hd = tl]
    | a :: b => 
      match hd with 
        | None => [False]
        | Some p => [hd <> tl] * 
            Exists nxt :@ option ptr, 
              hd --> node a nxt * llseg nxt tl b
      end
  end.
\end{verbatim}




Comparison points
\begin{itemize}
\item The use of Coq allows quantifiers in formula. (makes inference
  more difficult but allows more expressive types)
\item Ynot is capble of arbitrary inductive predicates
\item Ynot does not support concurrency which is a strength of
  smallfoot (race detection)
\item Smallfoot is very fast
\item A lot of the ``parallel examples'' don't actually use
  synchronization. These would be pretty trivial to implement in Ynot
  with a function:
\begin{verbatim}
SepParallel (r1 r2 : Type) (P_i Q_i : hprop)
  (P_e : r1 -> hprop) (Q_e : r2 -> hprop) :
     STsep (P_i) (P_e) -> STsep (Q_i) (Q_e)
  -> STsep (P_i * Q_i) (fun r:(r1 * r2) => 
               (P_e (fst r)) * (Q_e (snd r)))
\end{verbatim}
the more interesting aspect of the parallelism comes from the locking
mechanism, which could be encoded in Ynot but only after a little bit
of hacking. (smallfoot uses resource invariants to control this)
\end{itemize}

Smallfoot examples:
\begin{itemize}
\item circular list
\item doubly linked list
\item merge sort
\item ``memory manager'' (basically just a stack)
\item queue
\item tree
\item xor linked list segment
\item xdeq --- uses parallelism (reading and writing buffer)
\end{itemize}

\section{Other related work}
\section{Summary and conclusions}
Check that bibliography is working~\cite{htt}.

%\bibliographystyle{plainnat}
\bibliographystyle{plain}

\bibliography{bib}

\end{document}
